import csv
import os
import random
import math
import sys


# print("\n*********************************************************************************");
# print("finalprogram.py")
# sys.stdout.write("Directory ")
# print(os.getcwd())
# print("Created by Brock Tubre, Jacob Harlow, Azriel Richardson on 11/10/14 -- CSC475")
# print("*********************************************************************************\n");

# stores input csv files values
values = []
# 2d array to store trasition frequencies
transitions = [[0 for x in range(256)] for x in range(256)]
# list to stores wieghts for each transition
weights = [0.01 for x in range(256*256)]
bias = 1
alpha = 0.5

CSVfilelist = ['ANTRadioService.csv', 'Blurb.csv', 'ADRD.csv']

# ANTRadioService -- non-malicious
# Blurb -- non-mallicious
# ADRD -- mallicious
# AnserverBot -- mallicious

# Reads in CSV file and stores frequencies into transition[][] list and returns that list for further use
def FrequencyFunc(inputCSV):
	original = open(inputCSV, 'rU')
	reader = csv.reader(original)
	for row in reader:
		values = row

	# re initialize transitions list
	transitions = [[0 for x in range(256)] for x in range(256)]

	for i in range(len(values)):
		if(int(values[i]) > 0 and int(values[i+1]) > 0):
			first = int(values[i])
			second = int(values[i+1])
			transitions[first][second] += 1

	return transitions

# Learning Function reads in a csv file and runs it through to find the frequencies of each opt code transition occurance,
# it next send it to the hypothesis functions that makes a "guess". The error is calculated along with the changing of weights. 
def LearningFunc(csvfile):
	trans = FrequencyFunc(csvfile)
	hyp = Hypothesis(trans)
	error = trans[255][255] * 2 - 1 - hyp
	print("Error is: %s" % error)
	print("Mal value: %s" % trans[255][255])
	print(" ")
	k = 0
	for i in range(255):
		for j in range(255):
			weights[i] = weights[i] + alpha * error * trans[i][j]
			k += 1
	weights[256*256-1] = weights[256*256-1] + alpha * error * bias

# The hypothesis functions sums up all the weights with inputs, and returns wether the sum (summer) is
# 1 or -1
def Hypothesis(trans):
	k = 0
	summer = 0
	for i in range(255):
		for j in range(255):
			summer += weights[k] * trans[i][j]
			k += 1
	summer += bias * weights[256*256-1]
	print("Sum is: %s" % summer)
	if(summer > 1):
		return 1
	else:
		return -1

# The final piece that iterartes through the declased functions and adjust the alpha every single iteration
for i in range(150):
	print("Iteration: %s" % i)
	randomCSV = random.randint(0, 2)
	LearningFunc(CSVfilelist[randomCSV])
	alpha = alpha / 1.001












